#version 460
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout (set=0, binding=0) uniform UniformData {
    mat4 perspective;
    mat4 orthographic;
    vec3 sunDirection;
    vec2 resolution;
} ubo;

struct DrawData {
    mat4 transform;
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
};

layout (std430, set=0, binding=1) readonly buffer DrawDataBuffer {
    DrawData data[];
}drawData;

layout(std430, set=1, binding=0) writeonly buffer CulledMatrices {
    mat4 matrices[];
}culledMatrices;

struct DrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout(std430, set=1, binding=1) buffer DrawCommands {
    DrawCommand commands[];
}drawCommands;

layout(std430, set=1, binding=2) buffer CountBuffer{
    uint counts[];
}countBuffer;

struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 uv;
};

layout(std140, set=1, binding=3) readonly buffer VertexBuffer {
    Vertex vertices[];
}vertexBuffer;

layout(std430, set=1, binding=4) readonly buffer IndexBuffer {
    uint indices[];
}indexBuffer;

layout(push_constant) uniform PushConstants {
    uint baseIndex;
    uint pipelineIndex;
    uint drawCount;
}pushConstants;

bool isVisible(uint index)
{
    return true;
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index == 0) { atomicXor(countBuffer.counts[pushConstants.pipelineIndex], countBuffer.counts[pushConstants.pipelineIndex]); }
    if (index < pushConstants.drawCount) {
        if (isVisible(index)) {
            uint currentIndex = atomicAdd(countBuffer.counts[pushConstants.pipelineIndex], 1);
            uint outIndex = currentIndex + pushConstants.baseIndex;
            DrawData data = drawData.data[outIndex];
            culledMatrices.matrices[outIndex] = data.transform;
            drawCommands.commands[outIndex].indexCount = data.indexCount;
            drawCommands.commands[outIndex].instanceCount = 1;
            drawCommands.commands[outIndex].firstIndex = data.indexOffset;
            drawCommands.commands[outIndex].vertexOffset = data.vertexOffset;
            drawCommands.commands[outIndex].firstInstance = currentIndex;
        } else {

        }
    }
}